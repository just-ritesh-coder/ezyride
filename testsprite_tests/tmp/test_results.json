[
  {
    "projectId": "606606c9-6699-4ff2-a733-b4458e5b9ea7",
    "testId": "eede05ca-1c49-4ed9-b88b-66e2dc076572",
    "userId": "6418b418-4061-70b1-dd0d-5fb50c0a25cd",
    "title": "TC001-user_registration_with_valid_data",
    "description": "Verify that a user can successfully register with valid email, password, full name, and phone number.",
    "code": "import requests\n\ndef test_user_registration_with_valid_data():\n    base_url = \"http://localhost:5000\"\n    endpoint = \"/api/auth/register\"\n    url = base_url + endpoint\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    payload = {\n        \"email\": \"testuser@example.com\",\n        \"password\": \"StrongPassw0rd!\",\n        \"fullName\": \"Test User\",\n        \"phone\": \"+12345678901\"\n    }\n    try:\n        response = requests.post(url, json=payload, headers=headers, timeout=30)\n        assert response.status_code == 201 or response.status_code == 200, f\"Unexpected status code: {response.status_code}\"\n        data = response.json()\n        # Check for user ID in 'id', 'userId' or inside 'user' object\n        user_id_exists = ('id' in data) or ('userId' in data) or ('user' in data and ('id' in data['user'] or 'userId' in data['user']))\n        assert user_id_exists, \"Response JSON does not contain user ID\"\n        # Verify email if present\n        returned_email = \"\"\n        if 'email' in data:\n            returned_email = data.get('email', \"\").lower()\n        elif 'user' in data:\n            returned_email = data['user'].get('email', \"\").lower()\n        if returned_email:\n            assert returned_email == payload[\"email\"].lower(), \"Returned email does not match\"\n        # Ensure password is not returned\n        assert \"password\" not in data and (\"password\" not in data.get('user', {})), \"Password should not be returned in response\"\n    except requests.exceptions.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\ntest_user_registration_with_valid_data()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 36, in <module>\n  File \"<string>\", line 18, in test_user_registration_with_valid_data\nAssertionError: Unexpected status code: 400\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-07T11:20:58.245Z",
    "modified": "2025-12-07T11:22:05.666Z"
  },
  {
    "projectId": "606606c9-6699-4ff2-a733-b4458e5b9ea7",
    "testId": "9c368549-dc16-4711-b9a7-df78dd53cc26",
    "userId": "6418b418-4061-70b1-dd0d-5fb50c0a25cd",
    "title": "TC002-user_login_with_correct_credentials",
    "description": "Verify that a user can login successfully using valid email and password and receives a JWT token.",
    "code": "import requests\n\ndef test_user_login_with_correct_credentials():\n    base_url = \"http://localhost:5000\"\n    login_endpoint = \"/api/auth/login\"\n    url = base_url + login_endpoint\n\n    # Use a valid test email and password to login\n    # These must exist in the system or be seeded data for testing\n    payload = {\n        \"email\": \"testuser@example.com\",\n        \"password\": \"TestPassword123!\"\n    }\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    try:\n        response = requests.post(url, json=payload, headers=headers, timeout=30)\n        response.raise_for_status()  # Raise an HTTPError if the HTTP request returned an unsuccessful status code\n\n        json_response = response.json()\n        # Assert the login was successful and a JWT token is returned\n        assert \"token\" in json_response, \"JWT token not present in response\"\n        assert isinstance(json_response[\"token\"], str) and len(json_response[\"token\"]) > 0, \"JWT token is empty or not a string\"\n\n    except requests.exceptions.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\ntest_user_login_with_correct_credentials()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 20, in test_user_login_with_correct_credentials\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 401 Client Error: Unauthorized for url: http://localhost:5000/api/auth/login\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 30, in <module>\n  File \"<string>\", line 28, in test_user_login_with_correct_credentials\nAssertionError: Request failed: 401 Client Error: Unauthorized for url: http://localhost:5000/api/auth/login\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-07T11:20:58.253Z",
    "modified": "2025-12-07T11:22:04.348Z"
  },
  {
    "projectId": "606606c9-6699-4ff2-a733-b4458e5b9ea7",
    "testId": "0a72c078-d830-4b7d-b7ac-051f2d0d521a",
    "userId": "6418b418-4061-70b1-dd0d-5fb50c0a25cd",
    "title": "TC003-password_reset_request_and_completion",
    "description": "Verify that a user can request a password reset via email and reset the password using a valid token.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5000\"\nAUTH_TOKEN = \"b6b347741b87b53be66d0263b691738515836a8128f26c58be50c9f86a4008a21dfce004959dfd99f97fc0e6a0956406822bd9f96aabf5343688ade678f940ed\"\nHEADERS = {\n    \"Authorization\": f\"Bearer {AUTH_TOKEN}\",\n    \"Content-Type\": \"application/json\"\n}\nTIMEOUT = 30\n\ndef test_password_reset_request_and_completion():\n    # Step 1: Create a user to test with (unique email)\n    import uuid\n    email = f\"testuser_{uuid.uuid4().hex[:8]}@example.com\"\n    password = \"InitialPass123!\"\n    new_password = \"NewPass456!\"\n\n    register_payload = {\n        \"email\": email,\n        \"password\": password,\n        \"fullName\": \"Test User\",\n        \"phone\": \"1234567890\"\n    }\n\n    try:\n        # Register User\n        resp = requests.post(\n            f\"{BASE_URL}/api/auth/register\",\n            json=register_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert resp.status_code == 201, f\"User registration failed: {resp.text}\"\n\n        # Step 2: Request password reset via email\n        forgot_password_payload = {\"email\": email}\n        resp = requests.post(\n            f\"{BASE_URL}/api/auth/forgot-password\",\n            json=forgot_password_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert resp.status_code == 200, f\"Forgot password request failed: {resp.text}\"\n\n        # Step 3: Retrieve the reset token - typically from email, but here,\n        # since we can't actually get email, mock token retrieval by an API or test hook:\n        # Let's assume there is an internal test API to get the reset token for test emails:\n        token_resp = requests.get(\n            f\"{BASE_URL}/api/auth/test-reset-token\",\n            params={\"email\": email},\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert token_resp.status_code == 200, f\"Failed to retrieve reset token: {token_resp.text}\"\n        token_json = token_resp.json()\n        reset_token = token_json.get(\"resetToken\") or token_json.get(\"token\")\n        assert reset_token, \"Reset token not found in response\"\n\n        # Step 4: Complete the password reset request using the valid token\n        reset_password_payload = {\n            \"token\": reset_token,\n            \"password\": new_password\n        }\n        resp = requests.post(\n            f\"{BASE_URL}/api/auth/reset-password\",\n            json=reset_password_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert resp.status_code == 200, f\"Reset password failed: {resp.text}\"\n        reset_response_json = resp.json()\n        assert reset_response_json.get(\"message\"), \"Reset password response missing message\"\n\n        # Step 5: Verify that login works with new password\n        login_payload = {\n            \"email\": email,\n            \"password\": new_password\n        }\n        resp = requests.post(\n            f\"{BASE_URL}/api/auth/login\",\n            json=login_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert resp.status_code == 200, f\"Login with new password failed: {resp.text}\"\n        login_json = resp.json()\n        assert \"token\" in login_json, \"JWT token not received on login\"\n        assert login_json[\"token\"], \"Empty JWT token on login\"\n\n    finally:\n        # Cleanup: Delete the user if API supports deleting users by email or ID\n        # Try to fetch user id first via a test endpoint or profile\n        profile_resp = requests.get(\n            f\"{BASE_URL}/api/users/me\",\n            headers={**HEADERS, \"Authorization\": f\"Bearer {AUTH_TOKEN}\"},\n            timeout=TIMEOUT\n        )\n        if profile_resp.status_code == 200:\n            profile_json = profile_resp.json()\n            user_id = profile_json.get(\"id\") or profile_json.get(\"_id\")\n            if user_id:\n                requests.delete(\n                    f\"{BASE_URL}/api/users/{user_id}\",\n                    headers=HEADERS,\n                    timeout=TIMEOUT\n                )\n\ntest_password_reset_request_and_completion()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 108, in <module>\n  File \"<string>\", line 54, in test_password_reset_request_and_completion\nAssertionError: Failed to retrieve reset token: <!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<title>Error</title>\n</head>\n<body>\n<pre>Cannot GET /api/auth/test-reset-token</pre>\n</body>\n</html>\n\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-07T11:20:58.258Z",
    "modified": "2025-12-07T11:21:52.203Z"
  },
  {
    "projectId": "606606c9-6699-4ff2-a733-b4458e5b9ea7",
    "testId": "cc86c7d9-945b-4cd4-9fc7-069a819655cf",
    "userId": "6418b418-4061-70b1-dd0d-5fb50c0a25cd",
    "title": "TC004-post_ride_with_required_fields",
    "description": "Verify that a user can post a ride with origin, destination, date, seats available, and price per seat, and the ride status defaults to 'posted'.",
    "code": "import requests\nimport datetime\n\ndef test_post_ride_with_required_fields():\n    base_url = \"http://localhost:5000\"\n    token = \"b6b347741b87b53be66d0263b691738515836a8128f26c58be50c9f86a4008a21dfce004959dfd99f97fc0e6a0956406822bd9f96aabf5343688ade678f940ed\"\n    headers = {\n        \"Authorization\": f\"Bearer {token}\",\n        \"Content-Type\": \"application/json\"\n    }\n    post_ride_url = f\"{base_url}/api/rides\"\n    \n    # Prepare payload with required fields\n    payload = {\n        \"from\": \"New York\",\n        \"to\": \"Boston\",\n        \"date\": (datetime.datetime.utcnow() + datetime.timedelta(days=1)).isoformat() + \"Z\",\n        \"seatsAvailable\": 3,\n        \"pricePerSeat\": 25.50\n    }\n\n    ride_id = None\n    try:\n        response = requests.post(post_ride_url, json=payload, headers=headers, timeout=30)\n        assert response.status_code == 201, f\"Expected status code 201, got {response.status_code}\"\n        data = response.json()\n        # Validate presence of ride ID and correct data in response\n        assert \"id\" in data or \"_id\" in data, \"Response missing ride ID\"\n        ride_id = data.get(\"id\") or data.get(\"_id\")\n        assert data.get(\"from\") == payload[\"from\"], f\"Expected from='{payload['from']}', got '{data.get('from')}'\"\n        assert data.get(\"to\") == payload[\"to\"], f\"Expected to='{payload['to']}', got '{data.get('to')}'\"\n        # The date in response might be in a different format, at least check it's present\n        assert \"date\" in data, \"Response missing date\"\n        assert data.get(\"seatsAvailable\") == payload[\"seatsAvailable\"], f\"Expected seatsAvailable={payload['seatsAvailable']}, got {data.get('seatsAvailable')}\"\n        assert float(data.get(\"pricePerSeat\")) == payload[\"pricePerSeat\"], f\"Expected pricePerSeat={payload['pricePerSeat']}, got {data.get('pricePerSeat')}\"\n        # Status should default to 'posted'\n        assert data.get(\"status\") == \"posted\", f\"Expected status='posted', got '{data.get('status')}'\"\n\n    finally:\n        if ride_id:\n            # Clean up: delete the created ride\n            try:\n                delete_url = f\"{post_ride_url}/{ride_id}\"\n                del_response = requests.delete(delete_url, headers=headers, timeout=30)\n                assert del_response.status_code in (200, 204), f\"Failed to delete ride with id {ride_id}\"\n            except Exception:\n                pass\n\ntest_post_ride_with_required_fields()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 49, in <module>\n  File \"<string>\", line 25, in test_post_ride_with_required_fields\nAssertionError: Expected status code 201, got 401\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-07T11:20:58.263Z",
    "modified": "2025-12-07T11:21:52.193Z"
  },
  {
    "projectId": "606606c9-6699-4ff2-a733-b4458e5b9ea7",
    "testId": "39a5c51e-e6b1-499a-805e-52a3da7c3207",
    "userId": "6418b418-4061-70b1-dd0d-5fb50c0a25cd",
    "title": "TC005-search_rides_by_origin_and_destination",
    "description": "Verify that users can search for rides by origin and destination and receive rides matching the criteria with available seats and price.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5000\"\nHEADERS = {\n    \"Content-Type\": \"application/json\"\n}\n\ndef get_auth_token():\n    login_url = f\"{BASE_URL}/api/auth/login\"\n    # Assuming these are valid test user credentials\n    login_data = {\n        \"email\": \"testuser@example.com\",\n        \"password\": \"TestPassword123\"\n    }\n    response = requests.post(login_url, json=login_data, headers=HEADERS, timeout=30)\n    assert response.status_code == 200, f\"Login failed: {response.text}\"\n    token = response.json().get(\"token\")\n    assert token, \"No token received from login\"\n    return token\n\ndef test_search_rides_by_origin_and_destination():\n    token = get_auth_token()\n    auth_headers = {\n        \"Authorization\": f\"Bearer {token}\",\n        \"Content-Type\": \"application/json\"\n    }\n    ride_post_url = f\"{BASE_URL}/api/rides\"\n    ride_search_url = f\"{BASE_URL}/api/rides/search\"\n\n    ride_data = {\n        \"from\": \"New York\",\n        \"to\": \"Boston\",\n        \"date\": \"2024-07-01T10:00:00Z\",\n        \"seatsAvailable\": 3,\n        \"pricePerSeat\": 50.0\n    }\n\n    created_ride_id = None\n\n    try:\n        # Create a ride to ensure there is at least one matching ride\n        response_post = requests.post(ride_post_url, json=ride_data, headers=auth_headers, timeout=30)\n        assert response_post.status_code == 201, f\"Failed to create ride: {response_post.text}\"\n        ride_response = response_post.json()\n        created_ride_id = ride_response.get(\"id\")\n        assert created_ride_id, \"Created ride has no id\"\n\n        # Now search for rides by origin and destination\n        params = {\n            \"from\": ride_data[\"from\"],\n            \"to\": ride_data[\"to\"]\n        }\n        response_search = requests.get(ride_search_url, headers=auth_headers, params=params, timeout=30)\n        assert response_search.status_code == 200, f\"Search request failed: {response_search.text}\"\n        rides = response_search.json()\n        assert isinstance(rides, list), \"Search response is not a list\"\n\n        # Validate at least one ride matches criteria and has available seats and price\n        matching_rides = [ride for ride in rides if ride.get(\"from\") == ride_data[\"from\"]\n                          and ride.get(\"to\") == ride_data[\"to\"]\n                          and ride.get(\"seatsAvailable\", 0) > 0\n                          and \"pricePerSeat\" in ride]\n        assert len(matching_rides) > 0, \"No matching rides found with available seats and price\"\n\n    finally:\n        # Cleanup - delete the created ride if it exists\n        if created_ride_id:\n            delete_url = f\"{ride_post_url}/{created_ride_id}\"\n            requests.delete(delete_url, headers=auth_headers, timeout=30)\n\n\ntest_search_rides_by_origin_and_destination()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 72, in <module>\n  File \"<string>\", line 22, in test_search_rides_by_origin_and_destination\n  File \"<string>\", line 16, in get_auth_token\nAssertionError: Login failed: {\"message\":\"Invalid email or password\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-07T11:20:58.268Z",
    "modified": "2025-12-07T11:22:05.465Z"
  },
  {
    "projectId": "606606c9-6699-4ff2-a733-b4458e5b9ea7",
    "testId": "bca5fc05-484f-4b0e-9f8c-c1e7338f4069",
    "userId": "6418b418-4061-70b1-dd0d-5fb50c0a25cd",
    "title": "TC006-book_seats_on_available_ride",
    "description": "Verify that a user can book seats on an available ride, which reduces the available seats accordingly.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5000\"\nAUTH_TOKEN = \"b6b347741b87b53be66d0263b691738515836a8128f26c58be50c9f86a4008a21dfce004959dfd99f97fc0e6a0956406822bd9f96aabf5343688ade678f940ed\"\nHEADERS = {\n    \"Authorization\": f\"Bearer {AUTH_TOKEN}\",\n    \"Content-Type\": \"application/json\"\n}\nTIMEOUT = 30\n\n\ndef test_book_seats_on_available_ride():\n    # Step 1: Create a new ride to be booked\n    ride_payload = {\n        \"from\": \"CityA\",\n        \"to\": \"CityB\",\n        \"date\": \"2099-12-31T10:00:00Z\",\n        \"seatsAvailable\": 4,\n        \"pricePerSeat\": 50.0\n    }\n    ride_id = None\n    booking_id = None\n\n    try:\n        # Create ride\n        ride_response = requests.post(f\"{BASE_URL}/api/rides\", json=ride_payload, headers=HEADERS, timeout=TIMEOUT)\n        assert ride_response.status_code == 201, f\"Ride creation failed with status {ride_response.status_code}\"\n        ride_data = ride_response.json()\n        ride_id = ride_data.get(\"id\") or ride_data.get(\"_id\")\n        assert ride_id is not None, \"Created ride does not have an ID\"\n        initial_seats = ride_data.get(\"seatsAvailable\")\n        assert initial_seats == 4, f\"Initial seatsAvailable expected to be 4 but got {initial_seats}\"\n\n        # Step 2: Book seats on the ride\n        book_payload = {\n            \"rideId\": ride_id,\n            \"seatsBooked\": 2\n        }\n        booking_response = requests.post(f\"{BASE_URL}/api/bookings\", json=book_payload, headers=HEADERS, timeout=TIMEOUT)\n        assert booking_response.status_code == 201, f\"Booking failed with status {booking_response.status_code}\"\n        booking_data = booking_response.json()\n        booking_id = booking_data.get(\"id\") or booking_data.get(\"_id\")\n        assert booking_id is not None, \"Booking response does not contain an ID\"\n        booked_seats = booking_data.get(\"seatsBooked\")\n        assert booked_seats == 2, f\"Seats booked expected to be 2 but got {booked_seats}\"\n        booked_ride_id = booking_data.get(\"rideId\")\n        assert booked_ride_id == ride_id, \"Booking rideId does not match created rideId\"\n\n        # Step 3: Get ride details to confirm seatsAvailable is reduced accordingly\n        ride_detail_response = requests.get(f\"{BASE_URL}/api/rides/{ride_id}\", headers=HEADERS, timeout=TIMEOUT)\n        assert ride_detail_response.status_code == 200, f\"Failed to get ride details, status {ride_detail_response.status_code}\"\n        ride_detail_data = ride_detail_response.json()\n        seats_available_after_booking = ride_detail_data.get(\"seatsAvailable\")\n        expected_seats_after = initial_seats - booked_seats\n        assert seats_available_after_booking == expected_seats_after, \\\n            f\"Seats available after booking expected {expected_seats_after} but got {seats_available_after_booking}\"\n\n    finally:\n        # Cleanup booking\n        if booking_id:\n            try:\n                del_booking_resp = requests.delete(f\"{BASE_URL}/api/bookings/{booking_id}\", headers=HEADERS, timeout=TIMEOUT)\n                assert del_booking_resp.status_code in (200, 204), f\"Failed to delete booking with status {del_booking_resp.status_code}\"\n            except Exception:\n                pass\n\n        # Cleanup ride\n        if ride_id:\n            try:\n                del_ride_resp = requests.delete(f\"{BASE_URL}/api/rides/{ride_id}\", headers=HEADERS, timeout=TIMEOUT)\n                assert del_ride_resp.status_code in (200, 204), f\"Failed to delete ride with status {del_ride_resp.status_code}\"\n            except Exception:\n                pass\n\n\ntest_book_seats_on_available_ride()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 76, in <module>\n  File \"<string>\", line 27, in test_book_seats_on_available_ride\nAssertionError: Ride creation failed with status 401\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-07T11:20:58.273Z",
    "modified": "2025-12-07T11:21:50.437Z"
  },
  {
    "projectId": "606606c9-6699-4ff2-a733-b4458e5b9ea7",
    "testId": "5468a577-ddfd-4c19-bdb2-1b441da5ecc0",
    "userId": "6418b418-4061-70b1-dd0d-5fb50c0a25cd",
    "title": "TC007-initiate_payment_for_completed_ride",
    "description": "Verify that payment can only be initiated for completed rides, Razorpay order is created with the correct amount, and payment signature is verified.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5000\"\nTOKEN = \"b6b347741b87b53be66d0263b691738515836a8128f26c58be50c9f86a4008a21dfce004959dfd99f97fc0e6a0956406822bd9f96aabf5343688ade678f940ed\"\nHEADERS = {\n    \"Authorization\": f\"Bearer {TOKEN}\",\n    \"Content-Type\": \"application/json\"\n}\nTIMEOUT = 30\n\ndef test_initiate_payment_for_completed_ride():\n    ride_id = None\n    booking_id = None\n    ride2_id = None\n    booking2_id = None\n    try:\n        # Step 1: Create a ride with 'completed' status\n        ride_data = {\n            \"from\": \"Point A\",\n            \"to\": \"Point B\",\n            \"date\": \"2024-07-01T10:00:00Z\",\n            \"seatsAvailable\": 3,\n            \"pricePerSeat\": 150,\n            \"status\": \"posted\"\n        }\n        resp = requests.post(\n            f\"{BASE_URL}/api/rides\",\n            json=ride_data,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert resp.status_code == 201, f\"Ride creation failed: {resp.text}\"\n        ride = resp.json()\n        ride_id = ride.get(\"_id\")\n        assert ride_id, \"Ride ID missing in response\"\n\n        # Step 2: Update ride status to 'completed'\n        status_update_resp = requests.put(\n            f\"{BASE_URL}/api/rides/{ride_id}/status\",\n            json={\"status\": \"completed\"},\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert status_update_resp.status_code == 200, f\"Ride status update failed: {status_update_resp.text}\"\n\n        # Step 3: Book a seat on the completed ride\n        booking_data = {\n            \"rideId\": ride_id,\n            \"seatsBooked\": 1\n        }\n        booking_resp = requests.post(\n            f\"{BASE_URL}/api/bookings\",\n            json=booking_data,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert booking_resp.status_code == 201, f\"Booking failed: {booking_resp.text}\"\n        booking = booking_resp.json()\n        booking_id = booking.get(\"_id\")\n        assert booking_id, \"Booking ID missing in response\"\n\n        # Step 4: Initiate Razorpay order for the booking/payment\n        payment_order_resp = requests.post(\n            f\"{BASE_URL}/api/payments/razorpay/order\",\n            json={\"bookingId\": booking_id},\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert payment_order_resp.status_code == 200, f\"Payment order creation failed: {payment_order_resp.text}\"\n        payment_order = payment_order_resp.json()\n        assert \"id\" in payment_order and \"amount\" in payment_order, \"Razorpay order response missing fields\"\n        assert payment_order[\"amount\"] == 150 * 100, \"Razorpay order amount mismatch\"  # amount in paise\n\n        # Step 5: Simulate payment verification with dummy signature data\n        # Normally, signature and payment_id are generated by Razorpay payment flow - here we mock them\n        verify_payload = {\n            \"razorpay_order_id\": payment_order[\"id\"],\n            \"razorpay_payment_id\": \"pay_dummy123456789\",\n            \"razorpay_signature\": \"dummy_signature_for_testing\"\n        }\n        verify_resp = requests.post(\n            f\"{BASE_URL}/api/payments/razorpay/verify\",\n            json=verify_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        # We expect failure because signature is dummy or success if API mocks verification for testing\n        assert verify_resp.status_code in (200, 400), f\"Unexpected status from payment verify: {verify_resp.status_code}\"\n        verify_result = verify_resp.json()\n        if verify_resp.status_code == 200:\n            assert verify_result.get(\"success\") is True, \"Payment signature verification failed unexpectedly\"\n            # Optionally, check that booking payment status updated:\n            booking_status_resp = requests.get(\n                f\"{BASE_URL}/api/bookings/{booking_id}\",\n                headers=HEADERS,\n                timeout=TIMEOUT\n            )\n            assert booking_status_resp.status_code == 200, f\"Failed to get booking after payment verify: {booking_status_resp.text}\"\n            booking_after_payment = booking_status_resp.json()\n            assert booking_after_payment.get(\"paymentStatus\") == \"paid\", \"Booking payment status not updated to paid\"\n        else:\n            # If verification failed, check error message present\n            assert \"error\" in verify_result, \"Verify failed but no error message\"\n\n        # Step 6: Attempt to initiate payment for a non-completed ride and expect failure\n        # Create another ride which is not completed (default: posted)\n        ride2_resp = requests.post(\n            f\"{BASE_URL}/api/rides\",\n            json={\n                \"from\": \"Point C\",\n                \"to\": \"Point D\",\n                \"date\": \"2024-07-02T10:00:00Z\",\n                \"seatsAvailable\": 2,\n                \"pricePerSeat\": 100\n            },\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert ride2_resp.status_code == 201, f\"Second ride creation failed: {ride2_resp.text}\"\n        ride2 = ride2_resp.json()\n        ride2_id = ride2.get(\"_id\")\n        assert ride2_id, \"Second ride ID missing\"\n\n        # Book seat on second ride\n        booking2_resp = requests.post(\n            f\"{BASE_URL}/api/bookings\",\n            json={\"rideId\": ride2_id, \"seatsBooked\": 1},\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert booking2_resp.status_code == 201, f\"Second booking failed: {booking2_resp.text}\"\n        booking2 = booking2_resp.json()\n        booking2_id = booking2.get(\"_id\")\n        assert booking2_id, \"Second booking ID missing\"\n\n        # Try to initiate payment order for second (not completed) ride's booking - should fail\n        payment_order2_resp = requests.post(\n            f\"{BASE_URL}/api/payments/razorpay/order\",\n            json={\"bookingId\": booking2_id},\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        # Expecting error status code 400 or 403 for not allowed\n        assert payment_order2_resp.status_code in (400, 403), \"Payment initiation succeeded for non-completed ride, which is invalid\"\n\n    finally:\n        # Cleanup: Delete created bookings and rides\n        if booking_id:\n            try:\n                requests.delete(f\"{BASE_URL}/api/bookings/{booking_id}\", headers=HEADERS, timeout=TIMEOUT)\n            except Exception:\n                pass\n        if booking2_id:\n            try:\n                requests.delete(f\"{BASE_URL}/api/bookings/{booking2_id}\", headers=HEADERS, timeout=TIMEOUT)\n            except Exception:\n                pass\n        if ride_id:\n            try:\n                requests.delete(f\"{BASE_URL}/api/rides/{ride_id}\", headers=HEADERS, timeout=TIMEOUT)\n            except Exception:\n                pass\n        if ride2_id:\n            try:\n                requests.delete(f\"{BASE_URL}/api/rides/{ride2_id}\", headers=HEADERS, timeout=TIMEOUT)\n            except Exception:\n                pass\n\ntest_initiate_payment_for_completed_ride()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 169, in <module>\n  File \"<string>\", line 32, in test_initiate_payment_for_completed_ride\nAssertionError: Ride creation failed: {\"message\":\"Not authorized, token failed\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-07T11:20:58.279Z",
    "modified": "2025-12-07T11:22:17.539Z"
  },
  {
    "projectId": "606606c9-6699-4ff2-a733-b4458e5b9ea7",
    "testId": "62212e73-7ae3-42d2-ae8e-4ffe31a6a836",
    "userId": "6418b418-4061-70b1-dd0d-5fb50c0a25cd",
    "title": "TC008-update_ride_status_and_generate_otp",
    "description": "Verify that ride owners can update the ride status (posted, ongoing, completed, cancelled), generate an OTP for ride start, and verify the OTP before the ride starts.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5000\"\nTOKEN = \"b6b347741b87b53be66d0263b691738515836a8128f26c58be50c9f86a4008a21dfce004959dfd99f97fc0e6a0956406822bd9f96aabf5343688ade678f940ed\"\nHEADERS = {\n    \"Authorization\": f\"Bearer {TOKEN}\",\n    \"Content-Type\": \"application/json\"\n}\nTIMEOUT = 30\n\ndef test_update_ride_status_and_generate_otp():\n    ride_data = {\n        \"from\": \"CityA\",\n        \"to\": \"CityB\",\n        \"date\": \"2024-07-01T10:00:00Z\",\n        \"seatsAvailable\": 3,\n        \"pricePerSeat\": 100,\n        \"notes\": \"Test ride for OTP and status update\"\n    }\n\n    ride_id = None\n    try:\n        # Create a new ride\n        create_resp = requests.post(\n            f\"{BASE_URL}/api/rides\",\n            headers=HEADERS,\n            json=ride_data,\n            timeout=TIMEOUT\n        )\n        assert create_resp.status_code == 201, f\"Ride creation failed: {create_resp.text}\"\n        ride = create_resp.json()\n        ride_id = ride.get(\"_id\") or ride.get(\"id\")\n        assert ride_id is not None, \"Ride ID not returned after creation\"\n\n        # Update ride status to 'ongoing'\n        status_update = {\"status\": \"ongoing\"}\n        update_resp = requests.put(\n            f\"{BASE_URL}/api/rides/{ride_id}/status\",\n            headers=HEADERS,\n            json=status_update,\n            timeout=TIMEOUT\n        )\n        assert update_resp.status_code == 200, f\"Ride status update failed: {update_resp.text}\"\n        update_resp_json = update_resp.json()\n        assert update_resp_json.get(\"status\") == \"ongoing\", \"Ride status not updated to ongoing\"\n\n        # Generate OTP for ride start\n        otp_generate_resp = requests.post(\n            f\"{BASE_URL}/api/rides/{ride_id}/otp\",\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert otp_generate_resp.status_code == 200, f\"OTP generation failed: {otp_generate_resp.text}\"\n        otp_data = otp_generate_resp.json()\n        otp = otp_data.get(\"otp\")\n        assert otp is not None, \"OTP not returned in response\"\n\n        # Verify the OTP before ride start\n        otp_verify_payload = {\"otp\": otp}\n        otp_verify_resp = requests.post(\n            f\"{BASE_URL}/api/rides/{ride_id}/otp/verify\",\n            headers=HEADERS,\n            json=otp_verify_payload,\n            timeout=TIMEOUT\n        )\n        assert otp_verify_resp.status_code == 200, f\"OTP verification failed: {otp_verify_resp.text}\"\n        otp_verify_json = otp_verify_resp.json()\n        assert otp_verify_json.get(\"verified\") == True, \"OTP verification did not succeed\"\n\n        # Update ride status to 'completed'\n        status_complete = {\"status\": \"completed\"}\n        complete_resp = requests.put(\n            f\"{BASE_URL}/api/rides/{ride_id}/status\",\n            headers=HEADERS,\n            json=status_complete,\n            timeout=TIMEOUT\n        )\n        assert complete_resp.status_code == 200, f\"Ride status update to completed failed: {complete_resp.text}\"\n        complete_resp_json = complete_resp.json()\n        assert complete_resp_json.get(\"status\") == \"completed\", \"Ride status not updated to completed\"\n\n    finally:\n        if ride_id:\n            # Delete the created ride to clean up\n            delete_resp = requests.delete(\n                f\"{BASE_URL}/api/rides/{ride_id}\",\n                headers=HEADERS,\n                timeout=TIMEOUT\n            )\n            assert delete_resp.status_code == 200 or delete_resp.status_code == 204, f\"Failed to delete ride: {delete_resp.text}\"\n\ntest_update_ride_status_and_generate_otp()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 92, in <module>\n  File \"<string>\", line 30, in test_update_ride_status_and_generate_otp\nAssertionError: Ride creation failed: {\"message\":\"Not authorized, token failed\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-07T11:20:58.284Z",
    "modified": "2025-12-07T11:21:56.075Z"
  },
  {
    "projectId": "606606c9-6699-4ff2-a733-b4458e5b9ea7",
    "testId": "ba24f337-80d7-4d89-a0be-82d8a4676f72",
    "userId": "6418b418-4061-70b1-dd0d-5fb50c0a25cd",
    "title": "TC009-real_time_chat_access_and_messaging",
    "description": "Verify that users can join ride chat rooms, send and receive messages in real-time, and only ride participants can access the chat.",
    "code": "import requests\nimport time\nimport threading\nimport websocket\nimport json\n\nBASE_URL = \"http://localhost:5000\"\nTOKEN = \"b6b347741b87b53be66d0263b691738515836a8128f26c58be50c9f86a4008a21dfce004959dfd99f97fc0e6a0956406822bd9f96aabf5343688ade678f940ed\"\nHEADERS = {\"Authorization\": f\"Bearer {TOKEN}\", \"Content-Type\": \"application/json\"}\nTIMEOUT = 30\n\ndef test_real_time_chat_access_and_messaging():\n    # Step 1: Get current user info to identify user ID (needed for booking)\n    user_resp = requests.get(f\"{BASE_URL}/api/users/me\", headers=HEADERS, timeout=TIMEOUT)\n    assert user_resp.status_code == 200, f\"Failed to get user profile: {user_resp.text}\"\n    user = user_resp.json()\n    user_id = user.get(\"id\") or user.get(\"_id\")\n    assert user_id, \"User ID not found in profile\"\n\n    # Step 2: Create a new ride posted by this user\n    ride_payload = {\n        \"from\": \"LocationA\",\n        \"to\": \"LocationB\",\n        \"date\": \"2099-12-31T12:00:00Z\",\n        \"seatsAvailable\": 3,\n        \"pricePerSeat\": 100\n    }\n    ride_resp = requests.post(f\"{BASE_URL}/api/rides\", headers=HEADERS, json=ride_payload, timeout=TIMEOUT)\n    assert ride_resp.status_code == 201, f\"Failed to create ride: {ride_resp.text}\"\n    ride = ride_resp.json()\n    ride_id = ride.get(\"id\") or ride.get(\"_id\")\n    assert ride_id, \"Ride ID not found after creation\"\n\n    # Step 3: Book a seat on this ride (user is participant now)\n    booking_payload = {\n        \"rideId\": ride_id,\n        \"seatsBooked\": 1\n    }\n    booking_resp = requests.post(f\"{BASE_URL}/api/bookings\", headers=HEADERS, json=booking_payload, timeout=TIMEOUT)\n    assert booking_resp.status_code == 201, f\"Failed to book a seat: {booking_resp.text}\"\n    booking = booking_resp.json()\n    booking_id = booking.get(\"id\") or booking.get(\"_id\")\n    assert booking_id, \"Booking ID not found after creation\"\n\n    # Step 4: Connect to the ride chat WebSocket to join the chat room and send/receive messages\n    # Assuming the chat uses a websocket URL like ws://localhost:5000/ws/chats/{ride_id}?token=...\n    # We have only /api/chats endpoint in REST, but chat is realtime so websocket is used.\n\n    # Prepare websocket URL and auth\n    ws_url = f\"ws://localhost:5000/ws/chats/{ride_id}?token={TOKEN}\"\n\n    received_messages = []\n\n    def on_message(ws, message):\n        received_messages.append(json.loads(message))\n\n    def on_error(ws, error):\n        raise AssertionError(f\"WebSocket error: {error}\")\n\n    def on_close(ws):\n        pass\n\n    def on_open(ws):\n        # Send a test chat message once connection is open\n        msg = {\"type\": \"message\", \"content\": \"Hello from test\", \"rideId\": ride_id}\n        ws.send(json.dumps(msg))\n\n    # Create websocket app\n    ws = websocket.WebSocketApp(\n        ws_url,\n        on_message=on_message,\n        on_error=on_error,\n        on_close=on_close,\n        on_open=on_open,\n        header={\"Authorization\": f\"Bearer {TOKEN}\"}\n    )\n\n    # Run websocket in another thread to not block\n    ws_thread = threading.Thread(target=ws.run_forever)\n    ws_thread.daemon = True\n    ws_thread.start()\n\n    # Allow some time for connect, send, and receive\n    timeout_counter = 0\n    max_wait = 10\n    while timeout_counter < max_wait and len(received_messages) == 0:\n        time.sleep(1)\n        timeout_counter += 1\n\n    # Validate that we received the message back (echo or broadcast by server)\n    assert len(received_messages) > 0, \"No message received from chat server\"\n    found_hello = any(\"Hello from test\" in m.get(\"content\", \"\") for m in received_messages)\n    assert found_hello, \"Sent message not received in chat room\"\n\n    # Step 5: Verify that a user not booked cannot join this chat\n    # Create a second user by registering new user to test access restriction\n    new_user_email = \"tempuserrechattest@example.com\"\n    new_user_password = \"TestPass123!\"\n\n    try:\n        # Register new user\n        reg_payload = {\n            \"email\": new_user_email,\n            \"password\": new_user_password,\n            \"fullName\": \"Temp Chat User\",\n            \"phone\": \"1234567890\"\n        }\n        reg_resp = requests.post(f\"{BASE_URL}/api/auth/register\", json=reg_payload, timeout=TIMEOUT)\n        assert reg_resp.status_code == 201, f\"Failed to register temp user: {reg_resp.text}\"\n\n        # Login new user to get token\n        login_payload = {\"email\": new_user_email, \"password\": new_user_password}\n        login_resp = requests.post(f\"{BASE_URL}/api/auth/login\", json=login_payload, timeout=TIMEOUT)\n        assert login_resp.status_code == 200, f\"Failed to login temp user: {login_resp.text}\"\n        login_data = login_resp.json()\n        temp_token = login_data.get(\"token\")\n        assert temp_token, \"Temp user login token missing\"\n\n        # Attempt to connect websocket chat as unauthorized user\n        ws_url_unauth = f\"ws://localhost:5000/ws/chats/{ride_id}?token={temp_token}\"\n\n        error_received = []\n\n        def on_error_test(ws, error):\n            error_received.append(str(error))\n\n        ws_unauth = websocket.WebSocketApp(\n            ws_url_unauth,\n            on_message=lambda ws, msg: None,\n            on_error=on_error_test,\n            on_close=lambda ws: None,\n            on_open=lambda ws: None,\n            header={\"Authorization\": f\"Bearer {temp_token}\"}\n        )\n        ws_thread_unauth = threading.Thread(target=ws_unauth.run_forever)\n        ws_thread_unauth.daemon = True\n        ws_thread_unauth.start()\n\n        time.sleep(3)\n\n        # We expect some error or connection close or no valid messages allowed\n        # The server should deny access, so either error captured or closed connection quickly\n        assert len(error_received) > 0 or not ws_unauth.sock or not ws_unauth.sock.connected, \"Unauthorized user was able to connect to ride chat\"\n\n    finally:\n        # Cleanup booking\n        if booking_id:\n            requests.delete(f\"{BASE_URL}/api/bookings/{booking_id}\", headers=HEADERS, timeout=TIMEOUT)\n        # Cleanup ride\n        if ride_id:\n            requests.delete(f\"{BASE_URL}/api/rides/{ride_id}\", headers=HEADERS, timeout=TIMEOUT)\n        # Cleanup temp user\n        try:\n            # Assuming /api/users/me/delete or admin endpoint is not available,\n            # so skipping permanent deletion of temp user because no API info available.\n            pass\n        except Exception:\n            pass\n\n    ws.close()\n    ws_thread.join(timeout=1)\n\n\ntest_real_time_chat_access_and_messaging()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 4, in <module>\nModuleNotFoundError: No module named 'websocket'\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-07T11:20:58.289Z",
    "modified": "2025-12-07T11:21:56.077Z"
  },
  {
    "projectId": "606606c9-6699-4ff2-a733-b4458e5b9ea7",
    "testId": "8a1bd0ed-779f-42db-bc76-2b67740c013d",
    "userId": "6418b418-4061-70b1-dd0d-5fb50c0a25cd",
    "title": "TC010-trigger_sos_and_record_request",
    "description": "Verify that a user can trigger an SOS request and that the request is recorded in the database.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5000\"\nTOKEN = \"b6b347741b87b53be66d0263b691738515836a8128f26c58be50c9f86a4008a21dfce004959dfd99f97fc0e6a0956406822bd9f96aabf5343688ade678f940ed\"\nHEADERS = {\n    \"Authorization\": f\"Bearer {TOKEN}\",\n    \"Content-Type\": \"application/json\"\n}\n\ndef test_trigger_sos_and_record_request():\n    url = f\"{BASE_URL}/api/sos\"\n    payload = {}\n    response = requests.post(url, headers=HEADERS, json=payload, timeout=30)\n    assert response.status_code == 200 or response.status_code == 201, f\"Unexpected status code: {response.status_code}\"\n    data = response.json()\n    assert data is not None, \"SOS response data is None\"\n    assert \"id\" in data or \"_id\" in data, \"SOS request ID not returned\"\n    sos_id = data.get(\"id\") or data.get(\"_id\")\n    assert sos_id, \"SOS ID is empty\"\n\ntest_trigger_sos_and_record_request()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 21, in <module>\n  File \"<string>\", line 14, in test_trigger_sos_and_record_request\nAssertionError: Unexpected status code: 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-07T11:20:58.295Z",
    "modified": "2025-12-07T11:22:09.983Z"
  }
]
